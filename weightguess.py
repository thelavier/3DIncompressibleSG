import numpy as np

#Define the rescaling function to improve the inital guess for the damped Newton Solver
def Rescale_weights(bx, Z, psi):
    """
    Function returning weights w such that all cells in the 3d Laguerre tessellation of bx generated by (Z,w) have positive area.

    Inputs:
        bx: list or tuple defining domain [xmin, ymin, zmin, xmax, ymax, zmax]
        Z: numpy array of shape (n, 3) containing seed points
        psi: a guess at what the weights should be in the scaled box. 0 would be a Voronoi tessellation

    Outputs:
        w: numpy array of shape (n,) containing weight vector
        lambda_: scaling used when defining weights
        t: numpy array of shape (3,) containing translation used when defining weights
    """

    # Define rescaling so that rescaled seeds lie in a translated copy of bx
    Z_1 = Z[:, 0]
    min_Z_1 = np.min(Z_1)
    max_Z_1 = np.max(Z_1)

    Z_2 = Z[:, 1]
    min_Z_2 = np.min(Z_2)
    max_Z_2 = np.max(Z_2)

    Z_3 = Z[:, 2]
    min_Z_3 = np.min(Z_3)
    max_Z_3 = np.max(Z_3)

    lambda_1 = (bx[3]-bx[0]) / (max_Z_1-min_Z_1)
    lambda_2 = (bx[4]-bx[1]) / (max_Z_2-min_Z_2)
    lambda_3 = (bx[5]-bx[2]) / (max_Z_3-min_Z_3)

    lambda_ = min(lambda_1, lambda_2, lambda_3) * (1 - 1e-2)

    # Define translation to be the center of the domain minus the center of the rescaled seeds
    c_dom = [(bx[3]+bx[0])/2, (bx[4]+bx[1])/2, (bx[5]+bx[2])/2]
    c_zl = [lambda_*(min_Z_1 + max_Z_1)/2, lambda_*(min_Z_2 + max_Z_2)/2, lambda_*(min_Z_3 + max_Z_3)/2]
    t = np.array(c_dom) - np.array(c_zl)

    # Define weights
    w = (1 - lambda_) * np.square(np.linalg.norm(Z, axis = 1)) - 2 * np.dot(Z, t) - psi / lambda_

    return w, lambda_, t