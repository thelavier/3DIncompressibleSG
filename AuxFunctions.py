import numpy as np
import pysdot
from pysdot import OptimalTransport
from pysdot.domain_types import ConvexPolyhedraAssembly
import matplotlib.pyplot as plt
import matplotlib.animation as animation

#Define the cost function
def c(x, y):
    return (1/2) * abs(x[0] - y[0]) * abs(x[0] - y[0]) + (1/2) * abs(x[1] - y[1]) * abs(x[1] - y[1]) + (1/2) * abs(x[2] - y[2]) * abs(x[2] - y[2])

#Construct initial condition
def create_initial(N, maxx, maxy, maxz, minx, miny, minz, Type):
    """
    Function that constructs an initial condition. Allows for different distributions on different axes.

    Inputs:
        N: The number of seeds
        maxx: The maximum position in the x direction
        maxy: The maximum position in the y direction
        maxz: The maximum position in the z direction
        minx: The minimum position in the x direction
        miny: The minimum position in the y direction
        minz: The minimum position in the z direction
        Type: Type of initial condition to generate

    Outputs:
        matrix: The initial seeds positions
    """

    #Compute the cubic root of the number of seeds to later check that we can generate a valid lattice
    croot = round(N ** (1 / 3))

    if Type == 'uniform wsp':
        # Generate random values for the first and second columns
        col_0 = np.random.uniform(minx, maxx, size=N)
        col_1 = np.random.uniform(miny, maxy, size=N)

        # Generate random values for the third column
        col_2 = np.random.uniform( 2 * np.sin(col_0), 2 * np.sin(col_1), size=N)

        # Create the matrix by concatenating the columns
        matrix = np.column_stack((col_0, col_1, col_2))

        return matrix

    elif Type == 'normal':
        # Generate random values for the first and second columns
        col_0 = np.random.normal(0, maxx, size=N)
        col_1 = np.random.normal(0, maxy, size=N)

        # Generate random values for the third column
        col_2 = np.random.normal(0, maxz, size=N)

        # Create the matrix by concatenating the columns
        matrix = np.column_stack((col_0, col_1, col_2))

        return matrix

    elif Type == 'linear':
            # Generate  values for the first and second columns
            col_0 = np.linspace(minx, maxx, N)
            col_1 = np.linspace(miny, maxy, N)
    
            # Generate random values for the third column
            col_2 = np.linspace(minz, maxz, N)
    
            # Create the matrix by concatenating the columns
            matrix = np.column_stack((col_0, col_1, col_2))
    
            return matrix

    elif Type == 'linear wsp':
        # Generate  values for the first and second columns
        col_0 = np.linspace(minx, maxx, N)
        col_1 = np.linspace(miny, maxy, N)

        # Generate random values for the third column
        col_2 = 2 * np.sin(np.linspace(minz, maxz, N))

        # Create the matrix by concatenating the columns
        matrix = np.column_stack((col_0, col_1, col_2))

        return matrix

    elif Type == 'lattice' and N == croot ** 3:
        # Create coordinate arrays for each dimension
        col_0 = np.linspace(minx, maxx, croot)
        col_1 = np.linspace(miny, maxy, croot)
        col_2 = np.linspace(minz, maxz, croot)

        # Create a 3D lattice using meshgrid
        Col_0, Col_1, Col_2 = np.meshgrid(col_0, col_1, col_2)

        # Combine the coordinate arrays into a single matrix
        matrix = np.column_stack((Col_0.flatten(), Col_1.flatten(), Col_2.flatten()))

        # Construct matrix of perturbations
        perturbation = np.random.uniform(0.8, 1, size = (N, 3))

        return matrix*perturbation

    elif Type == 'lattice wsp' and N == croot ** 3:
        # Create coordinate arrays for each dimension
        col_0 = np.linspace(minx, maxx, croot)
        col_1 = np.linspace(miny, maxy, croot)
        col_2 = np.linspace(minz, maxz, croot)

        # Create a 3D lattice using meshgrid
        Col_0, Col_1, Col_2 = np.meshgrid(col_0, col_1, col_2)

        # Transform the Z corrdinates to make a sine perturbation
        Col_2 = 2 * np.sin(Col_0) * np.sin(Col_1)

        # Combine the coordinate arrays into a single matrix
        matrix = np.column_stack((Col_0.flatten(), Col_1.flatten(), Col_2.flatten()))

        # Construct matrix of perturbations
        perturbation = np.random.uniform(0.8, 1, size = (N, 3))

        return matrix * perturbation

    else:
        raise ValueError('Please specify the type of initial condition you want to use and make sure the number of seeds can generate a valid lattice.')

#Define the rescaling function to improve the inital guess for the damped Newton Solver
def Rescale_weights(bx, Z):
    """
    Function returning weights w such that all cells in the 3d Laguerre tessellation of bx generated by (Z,w) have positive area.

    Inputs:
        bx: list or tuple defining domain [xmin, ymin, zmin, xmax, ymax, zmax]
        Z: numpy array of shape (n, 3) containing seed points

    Outputs:
        w: numpy array of shape (n,) containing weight vector
        lambda_: scaling used when defining weights
        t: numpy array of shape (3,) containing translation used when defining weights
    """

    # Define rescaling so that rescaled seeds lie in a translated copy of bx
    Z_1 = Z[:, 0]
    min_Z_1 = np.min(Z_1)
    max_Z_1 = np.max(Z_1)

    Z_2 = Z[:, 1]
    min_Z_2 = np.min(Z_2)
    max_Z_2 = np.max(Z_2)

    Z_3 = Z[:, 2]
    min_Z_3 = np.min(Z_3)
    max_Z_3 = np.max(Z_3)

    lambda_1 = (bx[3]-bx[0]) / (max_Z_1-min_Z_1)
    lambda_2 = (bx[4]-bx[1]) / (max_Z_2-min_Z_2)
    lambda_3 = (bx[5]-bx[2]) / (max_Z_3-min_Z_3)

    lambda_ = min(lambda_1, lambda_2, lambda_3) * (1 - 1e-2)

    # Define translation to be the center of the domain minus the center of the rescaled seeds
    c_dom = [(bx[3]+bx[0])/2, (bx[4]+bx[1])/2, (bx[5]+bx[2])/2]
    c_zl = [lambda_*(min_Z_1 + max_Z_1)/2, lambda_*(min_Z_2 + max_Z_2)/2, lambda_*(min_Z_3 + max_Z_3)/2]
    t = np.array(c_dom) - np.array(c_zl)

    # Define weights
    w = (1 - lambda_) * np.square(np.linalg.norm(Z, axis = 1)) - 2 * np.dot(Z, t)

    return w, lambda_, t

#Constructs a domain to be passed to the laguerre functions
def make_domain(box=[-2, -2, 0, 2, 2, 1]):
    """
    Function returning the source domain for the optimal tranpsort problem.

    Inputs:
        box: list or tuple defining domain [xmin, ymin, zmin, xmax, ymax, zmax]
        img: the measure

    Outputs:
        domain: domain object for passing to optimal transport solver
    """
    domain = ConvexPolyhedraAssembly()
    domain.add_box([box[0], box[1], box[2]], [box[3], box[4], box[5]])
    return domain

#Find the centroids of a Laguerre Diagram
def laguerre_centroids(domain, Y, psi):
    """
    Function returning the centroids of a Laguerre diagram.

    Inputs:
        domain: The source domain of the optimal transport problem
        Y: The seed positions 
        psi: The corresponding weights for each seed

    Outputs:
        centroids: the centroids of the Laguerre diagram
    """
    return pysdot.PowerDiagram(Y, psi, domain).centroids()

#Solve the Optimal transport problem and return the centroids and weights
def ot_centroids(domain, Y, psi0, err_tol):
    """
    Function solving the optimal transport problem using the Damped Newton Method and returning the centroids of the optimal diagram.

    Inputs:
        domain: The source domain of the optimal transport problem
        Y: The seed positions 
        psi0: The inital weight guess for each seed
        err_tol: The error tolerance on the mass of the cells

    Outputs:
        centroids: The centroids of the optimal Laguerre diagram
        psi: The optimal weights
    """
    N = Y.shape[0] #Determine the number of seeds
    ot = OptimalTransport(positions = Y, weights = psi0, masses = domain.measure() / N * np.ones(N), domain = domain, linear_solver= 'Petsc') #Establish the Optimal Transport problem
    ot.set_stopping_criterion(err_tol, 'max delta masses') #Pick the stopping criterion to be the mass of the cells

    #print('Target masses before Damped Newton', ot.get_masses())
    #print('Weights before Damped Newton', ot.get_weights())
    #print('Mass before Damped Newton', ot.pd.integrals())

    ot.adjust_weights() #Use Damped Newton to find the optimal weight
    psi = ot.get_weights() #Extract the optimal weights from the solver

    #print('Mass after Damped Newton', ot.pd.integrals()) #Print the mass of each cell
    #print('Difference in initial and final weights', np.linalg.norm(psi0-psi)) #Check how different the initial guess is from the optimal weights

    return (laguerre_centroids(domain, Y, psi), psi)

#Animate the solution to the ODE
def animator(data, ZorC, Dim, tf):
    """
    Function animating the data produced by the optimal transport solver.

    Inputs:
        data: The data stored by the solver, must be a string
        ZorC: Decide if you want to animate the seeds or the weights, must also be a string
        Dim: Decide if you want to animate the seeds in 2D or 3D, must be a string
        tf: The 'Final time' for the solver, used to ensure that the frames and the animation interval are not jarring

    Outputs:
        animation: An animation of the seeds or the centroids depending on user choice
    """
    #Set up the animation 
    plt.rcParams['animation.ffmpeg_path'] = 'ffmpeg'
    global Z
    global C

    # Load the data
    loaded_data = np.load(data)

    # Access the individual arrays
    Z = loaded_data['data1']
    C = loaded_data['data2']

    #Establish Animation parameters
    Ndt = len(Z)

    #Create the plot
    fig = plt.figure()
    if Dim == '2D':
        ax = fig.add_subplot()
    elif Dim == '3D':
        ax = fig.add_subplot(projection='3d')
    else:
        print('Please specify the dimension of the animation!')

    def update(i):
        global Z
        global C

        #Update the plot
        if ZorC == 'Z':
            if Dim == '2D':
                ax.cla()
                ax.scatter(Z[i][:,0], Z[i][:,1], c = Z[i][:,2], cmap = 'jet', edgecolor = 'none', s = 8)
                ax.set_xlim([-10, 10])
                ax.set_ylim([-10, 10])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
            elif Dim == '3D':
                ax.cla()
                ax.scatter(Z[i][:,0], Z[i][:,1], Z[i][:,2], c = Z[i][:,2], cmap = 'jet', edgecolor = 'none', s = 8)
                ax.set_xlim([-10, 10])
                ax.set_ylim([-10, 10])
                ax.set_zlim([-10, 10])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
                ax.set_zlabel('Z')
            else:
                print('Please specify the dimension of the animation!')
        elif ZorC == 'C':
            if Dim == '2D':
                ax.cla()
                ax.scatter(C[i][:,0], C[i][:,1], c = C[i][:,2], cmap = 'jet', edgecolor = 'none', s = 8)
                ax.set_xlim([-3, 3])
                ax.set_ylim([-3, 3])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
            elif Dim == '3D':
                ax.cla()
                ax.scatter(C[i][:,0], C[i][:,1], C[i][:,2], c = C[i][:,2], cmap = 'jet', edgecolor = 'none', s = 8)
                ax.set_xlim([-3, 3])
                ax.set_ylim([-3, 3])
                ax.set_zlim([0, 1])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
                ax.set_zlabel('Z')
            else:
                print('Please specify the dimension of the animation!')
        else:
            print('Please specify if you want to animate the centroids or the seeds!')

    if ZorC == 'Z':
        if Dim == '2D':
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolSeedsin2D.gif', writer = FFwriter)
        elif Dim == '3D':
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolSeedsin3D.gif', writer = FFwriter)
        else:
            print('Please specify the dimension of the animation!')
    elif ZorC == 'C':
        if Dim == '2D':
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolCentroidsin2D.gif', writer = FFwriter)
        elif Dim == '3D':
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolCentroidsin3D.gif', writer = FFwriter)
        else:
            print('Please specify the dimension of the animation!')
    else:
            print('Please specify if you want to animate the centroids or the seeds!')