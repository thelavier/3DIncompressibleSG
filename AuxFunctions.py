import numpy as np
import pysdot
from pysdot import OptimalTransport
from pysdot.domain_types import ConvexPolyhedraAssembly
import matplotlib.pyplot as plt
import matplotlib.animation as animation

#Define the cost function
def c(x, y):
    return (1/2) * abs(x[0] - y[0]) * abs(x[0] - y[0]) + (1/2) * abs(x[1] - y[1]) * abs(x[1] - y[1]) + (1/2) * abs(x[2] - y[2]) * abs(x[2] - y[2])

#Define the rescaling function to improve the inital guess for the damped Newton Solver
def Rescale_weights(bx, Z):
    """
    Function returning weights w such that all cells in the 3d Laguerre tessellation of bx generated by (Z,w) have positive area.

    Inputs:
        bx: list or tuple defining domain [xmin, ymin, zmin, xmax, ymax, zmax]
        Z: numpy array of shape (n, 3) containing seed points

    Outputs:
        w: numpy array of shape (n,) containing weight vector
        lambda_: scaling used when defining weights
        t: numpy array of shape (3,) containing translation used when defining weights
    """

    # Define rescaling so that rescaled seeds lie in a translated copy of bx
    Z_1 = Z[:, 0]
    min_Z_1 = np.min(Z_1)
    max_Z_1 = np.max(Z_1)

    Z_2 = Z[:, 1]
    min_Z_2 = np.min(Z_2)
    max_Z_2 = np.max(Z_2)

    Z_3 = Z[:, 2]
    min_Z_3 = np.min(Z_3)
    max_Z_3 = np.max(Z_3)

    lambda_1 = (bx[3]-bx[0]) / (max_Z_1-min_Z_1)
    lambda_2 = (bx[4]-bx[1]) / (max_Z_2-min_Z_2)
    lambda_3 = (bx[5]-bx[2]) / (max_Z_3-min_Z_3)

    lambda_ = min(lambda_1, lambda_2, lambda_3) * (1 - 1e-2)

    # Define translation to be the center of the domain minus the center of the rescaled seeds
    c_dom = [(bx[3]+bx[0])/2, (bx[4]+bx[1])/2, (bx[5]+bx[2])/2]
    c_zl = [lambda_*(min_Z_1 + max_Z_1)/2, lambda_*(min_Z_2 + max_Z_2)/2, lambda_*(min_Z_3 + max_Z_3)/2]
    t = np.array(c_dom) - np.array(c_zl)

    # Define weights
    w = (1 - lambda_) * np.square(np.linalg.norm(Z, axis = 1)) - 2 * np.dot(Z, t)

    return w, lambda_, t

#Constructs a domain to be passed to the laguerre functions
def make_domain(box=[-2, -2, 0, 2, 2, 1]):
    """
    Function returning the source domain for the optimal tranpsort problem.

    Inputs:
        box: list or tuple defining domain [xmin, ymin, zmin, xmax, ymax, zmax]
        img: the measure

    Outputs:
        domain: domain object for passing to optimal transport solver
    """
    domain = ConvexPolyhedraAssembly()
    domain.add_box([box[0], box[1], box[2]], [box[3], box[4], box[5]])
    return domain

#Find the centroids of a Laguerre Diagram
def laguerre_centroids(domain, Y, psi):
    """
    Function returning the centroids of a Laguerre diagram.

    Inputs:
        domain: The source domain of the optimal transport problem
        Y: The seed positions 
        psi: The corresponding weights for each seed

    Outputs:
        centroids: the centroids of the Laguerre diagram
    """
    return pysdot.PowerDiagram(Y, psi, domain).centroids()

#Solve the Optimal transport problem and return the centroids and weights
def ot_centroids(domain, Y, psi0, err_tol):
    """
    Function solving the optimal transport problem using the Damped Newton Method and returning the centroids of the optimal diagram.

    Inputs:
        domain: The source domain of the optimal transport problem
        Y: The seed positions 
        psi0: The inital weight guess for each seed
        err_tol: The error tolerance on the mass of the cells

    Outputs:
        centroids: The centroids of the optimal Laguerre diagram
        psi: The optimal weights
    """
    N = Y.shape[0] #Determine the number of seeds
    ot = OptimalTransport(positions = Y, weights = psi0, masses = domain.measure() / N * np.ones(N), domain = domain) #Establish the Optimal Transport problem
    ot.set_stopping_criterion(err_tol, "max delta masses") #Pick the stopping criterion to be the mass of the cells

    #print('Target masses before Damped Newton', ot.get_masses())
    #print('Weights before Damped Newton', ot.get_weights())
    #print('Mass before Damped Newton', ot.pd.integrals())

    ot.adjust_weights() #Use Damped Newton to find the optimal weight
    psi = ot.get_weights() #Extract the optimal weights from the solver

    #print('Mass after Damped Newton', ot.pd.integrals()) #Print the mass of each cell
    #print('Difference in initial and final weights', np.linalg.norm(psi0-psi)) #Check how different the initial guess is from the optimal weights

    return (laguerre_centroids(domain, Y, psi), psi)

#Animate the solution to the ODE
def animator(data, ZorC, Dim, tf):
    """
    Function animating the data produced by the optimal transport solver.

    Inputs:
        data: The data stored by the solver, must be a string
        ZorC: Decide if you want to animate the seeds or the weights, must also be a string
        Dim: Decide if you want to animate the seeds in 2D or 3D, must be a string
        tf: The 'Final time' for the solver, used to ensure that the frames and the animation interval are not jarring

    Outputs:
        animation: An animation of the seeds or the centroids depending on user choice
    """
    #Set up the animation 
    plt.rcParams['animation.ffmpeg_path'] = 'ffmpeg'
    global Z
    global C

    # Load the data
    loaded_data = np.load(data)

    # Access the individual arrays
    Z = loaded_data['data1']
    C = loaded_data['data2']

    #Establish Animation parameters
    Ndt = len(Z)

    #Create the plot
    fig = plt.figure()
    if Dim == "2D":
        ax = fig.add_subplot()
    elif Dim == "3D":
        ax = fig.add_subplot(projection='3d')
    else:
        print("Please specify the dimension of the animation!")

    def update(i):
        global Z
        global C

        #Update the plot
        if ZorC == "Z":
            if Dim == "2D":
                ax.cla()
                ax.scatter(Z[i][:,0], Z[i][:,1], color = 'red', s=3)
                ax.set_xlim([-10, 10])
                ax.set_ylim([-10, 10])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
            elif Dim == "3D":
                ax.cla()
                ax.scatter(Z[i][:,0], Z[i][:,1], Z[i][:,2], color = 'red', s=3)
                ax.set_xlim([-10, 10])
                ax.set_ylim([-10, 10])
                ax.set_zlim([-10, 10])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
                ax.set_zlabel('Z')
            else:
                print("Please specify the dimension of the animation!")
        elif ZorC == "C":
            if Dim == "2D":
                ax.cla()
                ax.scatter(C[i][:,0], C[i][:,1], color = 'blue', s=3)
                ax.set_xlim([-3, 3])
                ax.set_ylim([-3, 3])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
            elif Dim == "3D":
                ax.cla()
                ax.scatter(C[i][:,0], C[i][:,1], C[i][:,2], color = 'blue', s=3)
                ax.set_xlim([-3, 3])
                ax.set_ylim([-3, 3])
                ax.set_zlim([0, 1])
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
                ax.set_zlabel('Z')
            else:
                print("Please specify the dimension of the animation!")
        else:
            print("Please specify if you want to animate the centroids or the seeds!")

    if ZorC == "Z":
        if Dim == "2D":
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolSeedsin2D.gif', writer = FFwriter)
        elif Dim == "3D":
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolSeedsin3D.gif', writer = FFwriter)
        else:
            print("Please specify the dimension of the animation!")
    elif ZorC == "C":
        if Dim == "2D":
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolCentroidsin2D.gif', writer = FFwriter)
        elif Dim == "3D":
            ani = animation.FuncAnimation(fig, update, frames = Ndt, interval = tf)
            FFwriter = animation.FFMpegWriter(fps = 1000)
            ani.save('SGSolCentroidsin3D.gif', writer = FFwriter)
        else:
            print("Please specify the dimension of the animation!")
    else:
            print("Please specify if you want to animate the centroids or the seeds!")